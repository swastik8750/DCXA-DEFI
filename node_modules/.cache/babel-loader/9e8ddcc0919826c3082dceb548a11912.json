{"ast":null,"code":"import { Contract, ethers } from \"ethers\";\nimport * as chains from \"./constants/chains\";\nimport COINS from \"./constants/coins\";\n\nconst ROUTER = require(\"./build/UniswapV2Router02.json\");\n\nconst ERC20 = require(\"./build/ERC20.json\");\n\nconst FACTORY = require(\"./build/IUniswapV2Factory.json\");\n\nconst PAIR = require(\"./build/IUniswapV2Pair.json\");\n\nexport function getProvider() {\n  return new ethers.providers.Web3Provider(window.ethereum);\n}\nexport function getSigner(provider) {\n  return provider.getSigner();\n}\nexport async function getNetwork(provider) {\n  const network = await provider.getNetwork();\n  return network.chainId;\n}\nexport function getRouter(address, signer) {\n  return new Contract(address, ROUTER.abi, signer);\n}\nexport async function checkNetwork(provider) {\n  const chainId = getNetwork(provider);\n\n  if (chains.networks.includes(chainId)) {\n    return true;\n  }\n\n  return false;\n}\nexport function getWeth(address, signer) {\n  return new Contract(address, ERC20.abi, signer);\n}\nexport function getFactory(address, signer) {\n  return new Contract(address, FACTORY.abi, signer);\n}\nexport async function getAccount() {\n  const accounts = await window.ethereum.request({\n    method: \"eth_requestAccounts\"\n  });\n  return accounts[0];\n} //This function checks if a ERC20 token exists for a given address\n//    `address` - The Ethereum address to be checked\n//    `signer` - The current signer\n\nexport function doesTokenExist(address, signer) {\n  try {\n    return new Contract(address, ERC20.abi, signer);\n  } catch (err) {\n    return false;\n  }\n}\nexport async function getDecimals(token) {\n  const decimals = await token.decimals().then(result => {\n    return result;\n  }).catch(error => {\n    console.log('No tokenDecimals function for this token, set to 0');\n    return 0;\n  });\n  return decimals;\n} // This function returns an object with 2 fields: `balance` which container's the account's balance in the particular token,\n// and `symbol` which is the abbreviation of the token name. To work correctly it must be provided with 4 arguments:\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `address` - An Ethereum address of the token to check for (either a token or AUT)\n//    `provider` - The current provider\n//    `signer` - The current signer\n\nexport async function getBalanceAndSymbol(accountAddress, address, provider, signer, weth_address, coins) {\n  try {\n    if (address === weth_address) {\n      const balanceRaw = await provider.getBalance(accountAddress);\n      return {\n        balance: ethers.utils.formatEther(balanceRaw),\n        symbol: coins[0].abbr\n      };\n    } else {\n      const token = new Contract(address, ERC20.abi, signer);\n      const tokenDecimals = await getDecimals(token);\n      const balanceRaw = await token.balanceOf(accountAddress);\n      const symbol = await token.symbol();\n      return {\n        balance: balanceRaw * 10 ** -tokenDecimals,\n        symbol: symbol\n      };\n    }\n  } catch (error) {\n    console.log('The getBalanceAndSymbol function had an error!');\n    console.log(error);\n    return false;\n  }\n} // This function swaps two particular tokens / AUT, it can handle switching from AUT to ERC20 token, ERC20 token to AUT, and ERC20 token to ERC20 token.\n// No error handling is done, so any issues can be caught with the use of .catch()\n// To work correctly, there needs to be 7 arguments:\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `amount` - A float or similar number representing the value of address1's token to trade\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `signer` - The current signer\n\nexport async function swapTokens(address1, address2, amount, routerContract, accountAddress, signer) {\n  const tokens = [address1, address2];\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const tokenDecimals = await getDecimals(token1);\n  const amountIn = ethers.utils.parseUnits(amount, tokenDecimals);\n  const amountOut = await routerContract.callStatic.getAmountsOut(amountIn, tokens);\n  await token1.approve(routerContract.address, amountIn);\n  const wethAddress = await routerContract.WETH();\n\n  if (address1 === wethAddress) {\n    // Eth -> Token\n    await routerContract.swapExactETHForTokens(amountOut[1], tokens, accountAddress, deadline, {\n      value: amountIn\n    });\n  } else if (address2 === wethAddress) {\n    // Token -> Eth\n    await routerContract.swapExactTokensForETH(amountIn, amountOut[1], tokens, accountAddress, deadline);\n  } else {\n    await routerContract.swapExactTokensForTokens(amountIn, amountOut[1], tokens, accountAddress, deadline);\n  }\n} //This function returns the conversion rate between two token addresses\n//    `address1` - An Ethereum address of the token to swaped from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to swaped to (either a token or AUT)\n//    `amountIn` - Amount of the token at address 1 to be swaped from\n//    `routerContract` - The router contract to carry out this swap\n\nexport async function getAmountOut(address1, address2, amountIn, routerContract, signer) {\n  try {\n    const token1 = new Contract(address1, ERC20.abi, signer);\n    const token1Decimals = await getDecimals(token1);\n    const token2 = new Contract(address2, ERC20.abi, signer);\n    const token2Decimals = await getDecimals(token2);\n    const values_out = await routerContract.getAmountsOut(ethers.utils.parseUnits(String(amountIn), token1Decimals), [address1, address2]);\n    const amount_out = values_out[1] * 10 ** -token2Decimals;\n    console.log('amount out: ', amount_out);\n    return Number(amount_out);\n  } catch {\n    return false;\n  }\n} // This function calls the pair contract to fetch the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2. Some extra logic was needed to make sure that the results were returned in the correct order, as\n// `pair.getReserves()` would always return the reserves in the same order regardless of which order the addresses were.\n//    `address1` - An Ethereum address of the token to trade from (either a ERC20 token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a ERC20 token or AUT)\n//    `pair` - The pair contract for the two tokens\n\nexport async function fetchReserves(address1, address2, pair, signer) {\n  try {\n    // Get decimals for each coin\n    const coin1 = new Contract(address1, ERC20.abi, signer);\n    const coin2 = new Contract(address2, ERC20.abi, signer);\n    const coin1Decimals = await getDecimals(coin1);\n    const coin2Decimals = await getDecimals(coin2); // Get reserves\n\n    const reservesRaw = await pair.getReserves(); // Put the results in the right order\n\n    const results = [(await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1], (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0]]; // Scale each to the right decimal place\n\n    return [results[0] * 10 ** -coin1Decimals, results[1] * 10 ** -coin2Decimals];\n  } catch (err) {\n    console.log(\"error!\");\n    console.log(err);\n    return [0, 0];\n  }\n} // This function returns the reserves stored in a the liquidity pool between the token of address1 and the token\n// of address2, as well as the liquidity tokens owned by accountAddress for that pair.\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\n//    `factory` - The current factory\n//    `signer` - The current signer\n\nexport async function getReserves(address1, address2, factory, signer, accountAddress) {\n  const pairAddress = await factory.getPair(address1, address2);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n  if (pairAddress !== '0x0000000000000000000000000000000000000000') {\n    const reservesRaw = await fetchReserves(address1, address2, pair, signer);\n    const liquidityTokens_BN = await pair.balanceOf(accountAddress);\n    const liquidityTokens = Number(ethers.utils.formatEther(liquidityTokens_BN));\n    return [reservesRaw[0].toPrecision(6), reservesRaw[1].toPrecision(6), liquidityTokens];\n  } else {\n    console.log(\"no reserves yet\");\n    return [0, 0, 0];\n  }\n}","map":{"version":3,"sources":["G:/MyProfile/FUTURE_TRACK/DCXA-DEFI/src/ethereumFunctions.js"],"names":["Contract","ethers","chains","COINS","ROUTER","require","ERC20","FACTORY","PAIR","getProvider","providers","Web3Provider","window","ethereum","getSigner","provider","getNetwork","network","chainId","getRouter","address","signer","abi","checkNetwork","networks","includes","getWeth","getFactory","getAccount","accounts","request","method","doesTokenExist","err","getDecimals","token","decimals","then","result","catch","error","console","log","getBalanceAndSymbol","accountAddress","weth_address","coins","balanceRaw","getBalance","balance","utils","formatEther","symbol","abbr","tokenDecimals","balanceOf","swapTokens","address1","address2","amount","routerContract","tokens","time","Math","floor","Date","now","deadline","BigNumber","from","token1","amountIn","parseUnits","amountOut","callStatic","getAmountsOut","approve","wethAddress","WETH","swapExactETHForTokens","value","swapExactTokensForETH","swapExactTokensForTokens","getAmountOut","token1Decimals","token2","token2Decimals","values_out","String","amount_out","Number","fetchReserves","pair","coin1","coin2","coin1Decimals","coin2Decimals","reservesRaw","getReserves","results","token0","factory","pairAddress","getPair","liquidityTokens_BN","liquidityTokens","toPrecision"],"mappings":"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","sourcesContent":["import { Contract, ethers } from \"ethers\";\r\nimport * as chains from \"./constants/chains\";\r\nimport COINS from \"./constants/coins\";\r\n\r\nconst ROUTER = require(\"./build/UniswapV2Router02.json\");\r\nconst ERC20 = require(\"./build/ERC20.json\");\r\nconst FACTORY = require(\"./build/IUniswapV2Factory.json\");\r\nconst PAIR = require(\"./build/IUniswapV2Pair.json\");\r\n\r\nexport function getProvider() {\r\n  return new ethers.providers.Web3Provider(window.ethereum);\r\n}\r\n\r\nexport function getSigner(provider) {\r\n  return provider.getSigner();\r\n}\r\n\r\nexport async function getNetwork(provider) {\r\n  const network = await provider.getNetwork();\r\n  return network.chainId;\r\n}\r\n\r\nexport function getRouter(address, signer) {\r\n  return new Contract(address, ROUTER.abi, signer);\r\n}\r\n\r\nexport async function checkNetwork(provider) {\r\n  const chainId = getNetwork(provider);\r\n  if (chains.networks.includes(chainId)){\r\n    return true\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function getWeth(address, signer) {\r\n  return new Contract(address, ERC20.abi, signer);\r\n}\r\n\r\nexport function getFactory(address, signer) {\r\n  return new Contract(address, FACTORY.abi, signer);\r\n}\r\n\r\nexport async function getAccount() {\r\n  const accounts = await window.ethereum.request({\r\n    method: \"eth_requestAccounts\",\r\n  });\r\n\r\n  return accounts[0];\r\n}\r\n\r\n//This function checks if a ERC20 token exists for a given address\r\n//    `address` - The Ethereum address to be checked\r\n//    `signer` - The current signer\r\nexport function doesTokenExist(address, signer) {\r\n  try {\r\n    return new Contract(address, ERC20.abi, signer);\r\n  } catch (err) {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function getDecimals(token) {\r\n  const decimals = await token.decimals().then((result) => {\r\n      return result;\r\n    }).catch((error) => {\r\n      console.log('No tokenDecimals function for this token, set to 0');\r\n      return 0;\r\n    });\r\n    return decimals;\r\n}\r\n\r\n// This function returns an object with 2 fields: `balance` which container's the account's balance in the particular token,\r\n// and `symbol` which is the abbreviation of the token name. To work correctly it must be provided with 4 arguments:\r\n//    `accountAddress` - An Ethereum address of the current user's account\r\n//    `address` - An Ethereum address of the token to check for (either a token or AUT)\r\n//    `provider` - The current provider\r\n//    `signer` - The current signer\r\nexport async function getBalanceAndSymbol(\r\n  accountAddress,\r\n  address,\r\n  provider,\r\n  signer,\r\n  weth_address,\r\n  coins\r\n) {\r\n  try {\r\n    if (address === weth_address) {\r\n      const balanceRaw = await provider.getBalance(accountAddress);\r\n\r\n      return {\r\n        balance: ethers.utils.formatEther(balanceRaw),\r\n        symbol: coins[0].abbr,\r\n      };\r\n    } else {\r\n      const token = new Contract(address, ERC20.abi, signer);\r\n      const tokenDecimals = await getDecimals(token);\r\n      const balanceRaw = await token.balanceOf(accountAddress);\r\n      const symbol = await token.symbol();\r\n\r\n      return {\r\n        balance: balanceRaw*10**(-tokenDecimals),\r\n        symbol: symbol,\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.log ('The getBalanceAndSymbol function had an error!');\r\n    console.log (error)\r\n    return false;\r\n  }\r\n}\r\n\r\n// This function swaps two particular tokens / AUT, it can handle switching from AUT to ERC20 token, ERC20 token to AUT, and ERC20 token to ERC20 token.\r\n// No error handling is done, so any issues can be caught with the use of .catch()\r\n// To work correctly, there needs to be 7 arguments:\r\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\r\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\r\n//    `amount` - A float or similar number representing the value of address1's token to trade\r\n//    `routerContract` - The router contract to carry out this trade\r\n//    `accountAddress` - An Ethereum address of the current user's account\r\n//    `signer` - The current signer\r\nexport async function swapTokens(\r\n  address1,\r\n  address2,\r\n  amount,\r\n  routerContract,\r\n  accountAddress,\r\n  signer\r\n) {\r\n  const tokens = [address1, address2];\r\n  const time = Math.floor(Date.now() / 1000) + 200000;\r\n  const deadline = ethers.BigNumber.from(time);\r\n\r\n  const token1 = new Contract(address1, ERC20.abi, signer);\r\n  const tokenDecimals = await getDecimals(token1);\r\n  \r\n  const amountIn = ethers.utils.parseUnits(amount, tokenDecimals);\r\n  const amountOut = await routerContract.callStatic.getAmountsOut(\r\n    amountIn,\r\n    tokens\r\n  );\r\n\r\n  await token1.approve(routerContract.address, amountIn);\r\n  const wethAddress = await routerContract.WETH();\r\n\r\n  if (address1 === wethAddress) {\r\n    // Eth -> Token\r\n    await routerContract.swapExactETHForTokens(\r\n      amountOut[1],\r\n      tokens,\r\n      accountAddress,\r\n      deadline,\r\n      { value: amountIn }\r\n    );\r\n  } else if (address2 === wethAddress) {\r\n    // Token -> Eth\r\n    await routerContract.swapExactTokensForETH(\r\n      amountIn,\r\n      amountOut[1],\r\n      tokens,\r\n      accountAddress,\r\n      deadline\r\n    );\r\n  } else {\r\n    await routerContract.swapExactTokensForTokens(\r\n      amountIn,\r\n      amountOut[1],\r\n      tokens,\r\n      accountAddress,\r\n      deadline\r\n    );\r\n  }\r\n}\r\n\r\n//This function returns the conversion rate between two token addresses\r\n//    `address1` - An Ethereum address of the token to swaped from (either a token or AUT)\r\n//    `address2` - An Ethereum address of the token to swaped to (either a token or AUT)\r\n//    `amountIn` - Amount of the token at address 1 to be swaped from\r\n//    `routerContract` - The router contract to carry out this swap\r\nexport async function getAmountOut(\r\n  address1,\r\n  address2,\r\n  amountIn,\r\n  routerContract,\r\n  signer\r\n) {\r\n  try {\r\n    const token1 = new Contract(address1, ERC20.abi, signer);\r\n    const token1Decimals = await getDecimals(token1);\r\n\r\n    const token2 = new Contract(address2, ERC20.abi, signer);\r\n    const token2Decimals = await getDecimals(token2);\r\n\r\n    const values_out = await routerContract.getAmountsOut(\r\n      ethers.utils.parseUnits(String(amountIn), token1Decimals),\r\n      [address1, address2]\r\n    );\r\n    const amount_out = values_out[1]*10**(-token2Decimals);\r\n    console.log('amount out: ', amount_out)\r\n    return Number(amount_out);\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n// This function calls the pair contract to fetch the reserves stored in a the liquidity pool between the token of address1 and the token\r\n// of address2. Some extra logic was needed to make sure that the results were returned in the correct order, as\r\n// `pair.getReserves()` would always return the reserves in the same order regardless of which order the addresses were.\r\n//    `address1` - An Ethereum address of the token to trade from (either a ERC20 token or AUT)\r\n//    `address2` - An Ethereum address of the token to trade to (either a ERC20 token or AUT)\r\n//    `pair` - The pair contract for the two tokens\r\nexport async function fetchReserves(address1, address2, pair, signer) {\r\n  try {\r\n\r\n    // Get decimals for each coin\r\n    const coin1 = new Contract(address1, ERC20.abi, signer);\r\n    const coin2 = new Contract(address2, ERC20.abi, signer);\r\n\r\n    const coin1Decimals = await getDecimals(coin1);\r\n    const coin2Decimals = await getDecimals(coin2);\r\n\r\n    // Get reserves\r\n    const reservesRaw = await pair.getReserves();\r\n\r\n    // Put the results in the right order\r\n    const results =  [\r\n      (await pair.token0()) === address1 ? reservesRaw[0] : reservesRaw[1],\r\n      (await pair.token1()) === address2 ? reservesRaw[1] : reservesRaw[0],\r\n    ];\r\n\r\n    // Scale each to the right decimal place\r\n    return [\r\n      (results[0]*10**(-coin1Decimals)),\r\n      (results[1]*10**(-coin2Decimals))\r\n    ]\r\n  } catch (err) {\r\n    console.log(\"error!\");\r\n    console.log(err);\r\n    return [0, 0];\r\n  }\r\n}\r\n\r\n// This function returns the reserves stored in a the liquidity pool between the token of address1 and the token\r\n// of address2, as well as the liquidity tokens owned by accountAddress for that pair.\r\n//    `address1` - An Ethereum address of the token to trade from (either a token or AUT)\r\n//    `address2` - An Ethereum address of the token to trade to (either a token or AUT)\r\n//    `factory` - The current factory\r\n//    `signer` - The current signer\r\nexport async function getReserves(\r\n  address1,\r\n  address2,\r\n  factory,\r\n  signer,\r\n  accountAddress\r\n) {\r\n  const pairAddress = await factory.getPair(address1, address2);\r\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\r\n\r\n  if (pairAddress !== '0x0000000000000000000000000000000000000000'){\r\n\r\n    const reservesRaw = await fetchReserves(address1, address2, pair, signer);\r\n    const liquidityTokens_BN = await pair.balanceOf(accountAddress);\r\n    const liquidityTokens = Number(\r\n      ethers.utils.formatEther(liquidityTokens_BN)\r\n    );\r\n  \r\n    return [\r\n      reservesRaw[0].toPrecision(6),\r\n      reservesRaw[1].toPrecision(6),\r\n      liquidityTokens,\r\n    ];\r\n  } else {\r\n    console.log(\"no reserves yet\");\r\n    return [0,0,0];\r\n  }\r\n\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}